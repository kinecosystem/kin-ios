// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: storage.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

#import <stdatomic.h>

#import "Storage.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"

#pragma mark - KinStorageStorageRoot

@implementation KinStorageStorageRoot

// No extensions in the file and no imports, so no need to generate
// +extensionRegistry.

@end

#pragma mark - KinStorageStorageRoot_FileDescriptor

static GPBFileDescriptor *KinStorageStorageRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"kin.storage.v1"
                                                 objcPrefix:@"KinStorage"
                                                     syntax:GPBFileSyntaxProto3];
  }
  return descriptor;
}

#pragma mark - KinStoragePrivateKey

@implementation KinStoragePrivateKey

@dynamic value;

typedef struct KinStoragePrivateKey__storage_ {
  uint32_t _has_storage_[1];
  NSData *value;
} KinStoragePrivateKey__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "value",
        .dataTypeSpecific.className = NULL,
        .number = KinStoragePrivateKey_FieldNumber_Value,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(KinStoragePrivateKey__storage_, value),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[KinStoragePrivateKey class]
                                     rootClass:[KinStorageStorageRoot class]
                                          file:KinStorageStorageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(KinStoragePrivateKey__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - KinStoragePublicKey

@implementation KinStoragePublicKey

@dynamic value;

typedef struct KinStoragePublicKey__storage_ {
  uint32_t _has_storage_[1];
  NSData *value;
} KinStoragePublicKey__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "value",
        .dataTypeSpecific.className = NULL,
        .number = KinStoragePublicKey_FieldNumber_Value,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(KinStoragePublicKey__storage_, value),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[KinStoragePublicKey class]
                                     rootClass:[KinStorageStorageRoot class]
                                          file:KinStorageStorageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(KinStoragePublicKey__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - KinStorageKinBalance

@implementation KinStorageKinBalance

@dynamic quarkAmount;
@dynamic pendingQuarkAmount;

typedef struct KinStorageKinBalance__storage_ {
  uint32_t _has_storage_[1];
  int64_t quarkAmount;
  int64_t pendingQuarkAmount;
} KinStorageKinBalance__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "quarkAmount",
        .dataTypeSpecific.className = NULL,
        .number = KinStorageKinBalance_FieldNumber_QuarkAmount,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(KinStorageKinBalance__storage_, quarkAmount),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "pendingQuarkAmount",
        .dataTypeSpecific.className = NULL,
        .number = KinStorageKinBalance_FieldNumber_PendingQuarkAmount,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(KinStorageKinBalance__storage_, pendingQuarkAmount),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[KinStorageKinBalance class]
                                     rootClass:[KinStorageStorageRoot class]
                                          file:KinStorageStorageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(KinStorageKinBalance__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - KinStorageKinAccount

@implementation KinStorageKinAccount

@dynamic hasPublicKey, publicKey;
@dynamic hasPrivateKey, privateKey;
@dynamic hasBalance, balance;
@dynamic status;
@dynamic sequenceNumber;
@dynamic accountsArray, accountsArray_Count;

typedef struct KinStorageKinAccount__storage_ {
  uint32_t _has_storage_[1];
  KinStorageKinAccount_Status status;
  KinStoragePublicKey *publicKey;
  KinStoragePrivateKey *privateKey;
  KinStorageKinBalance *balance;
  NSMutableArray *accountsArray;
  int64_t sequenceNumber;
} KinStorageKinAccount__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "publicKey",
        .dataTypeSpecific.className = GPBStringifySymbol(KinStoragePublicKey),
        .number = KinStorageKinAccount_FieldNumber_PublicKey,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(KinStorageKinAccount__storage_, publicKey),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "privateKey",
        .dataTypeSpecific.className = GPBStringifySymbol(KinStoragePrivateKey),
        .number = KinStorageKinAccount_FieldNumber_PrivateKey,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(KinStorageKinAccount__storage_, privateKey),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "balance",
        .dataTypeSpecific.className = GPBStringifySymbol(KinStorageKinBalance),
        .number = KinStorageKinAccount_FieldNumber_Balance,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(KinStorageKinAccount__storage_, balance),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "status",
        .dataTypeSpecific.enumDescFunc = KinStorageKinAccount_Status_EnumDescriptor,
        .number = KinStorageKinAccount_FieldNumber_Status,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(KinStorageKinAccount__storage_, status),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "sequenceNumber",
        .dataTypeSpecific.className = NULL,
        .number = KinStorageKinAccount_FieldNumber_SequenceNumber,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(KinStorageKinAccount__storage_, sequenceNumber),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "accountsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(KinStoragePublicKey),
        .number = KinStorageKinAccount_FieldNumber_AccountsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(KinStorageKinAccount__storage_, accountsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[KinStorageKinAccount class]
                                     rootClass:[KinStorageStorageRoot class]
                                          file:KinStorageStorageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(KinStorageKinAccount__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t KinStorageKinAccount_Status_RawValue(KinStorageKinAccount *message) {
  GPBDescriptor *descriptor = [KinStorageKinAccount descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:KinStorageKinAccount_FieldNumber_Status];
  return GPBGetMessageInt32Field(message, field);
}

void SetKinStorageKinAccount_Status_RawValue(KinStorageKinAccount *message, int32_t value) {
  GPBDescriptor *descriptor = [KinStorageKinAccount descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:KinStorageKinAccount_FieldNumber_Status];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - Enum KinStorageKinAccount_Status

GPBEnumDescriptor *KinStorageKinAccount_Status_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "Unregistered\000Registered\000";
    static const int32_t values[] = {
        KinStorageKinAccount_Status_Unregistered,
        KinStorageKinAccount_Status_Registered,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(KinStorageKinAccount_Status)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:KinStorageKinAccount_Status_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL KinStorageKinAccount_Status_IsValidValue(int32_t value__) {
  switch (value__) {
    case KinStorageKinAccount_Status_Unregistered:
    case KinStorageKinAccount_Status_Registered:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - KinStorageKinTransaction

@implementation KinStorageKinTransaction

@dynamic envelopeXdr;
@dynamic status;
@dynamic timestamp;
@dynamic resultXdr;
@dynamic pagingToken;

typedef struct KinStorageKinTransaction__storage_ {
  uint32_t _has_storage_[1];
  KinStorageKinTransaction_Status status;
  NSData *envelopeXdr;
  NSData *resultXdr;
  NSString *pagingToken;
  int64_t timestamp;
} KinStorageKinTransaction__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "envelopeXdr",
        .dataTypeSpecific.className = NULL,
        .number = KinStorageKinTransaction_FieldNumber_EnvelopeXdr,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(KinStorageKinTransaction__storage_, envelopeXdr),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "status",
        .dataTypeSpecific.enumDescFunc = KinStorageKinTransaction_Status_EnumDescriptor,
        .number = KinStorageKinTransaction_FieldNumber_Status,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(KinStorageKinTransaction__storage_, status),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "timestamp",
        .dataTypeSpecific.className = NULL,
        .number = KinStorageKinTransaction_FieldNumber_Timestamp,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(KinStorageKinTransaction__storage_, timestamp),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "resultXdr",
        .dataTypeSpecific.className = NULL,
        .number = KinStorageKinTransaction_FieldNumber_ResultXdr,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(KinStorageKinTransaction__storage_, resultXdr),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "pagingToken",
        .dataTypeSpecific.className = NULL,
        .number = KinStorageKinTransaction_FieldNumber_PagingToken,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(KinStorageKinTransaction__storage_, pagingToken),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[KinStorageKinTransaction class]
                                     rootClass:[KinStorageStorageRoot class]
                                          file:KinStorageStorageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(KinStorageKinTransaction__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t KinStorageKinTransaction_Status_RawValue(KinStorageKinTransaction *message) {
  GPBDescriptor *descriptor = [KinStorageKinTransaction descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:KinStorageKinTransaction_FieldNumber_Status];
  return GPBGetMessageInt32Field(message, field);
}

void SetKinStorageKinTransaction_Status_RawValue(KinStorageKinTransaction *message, int32_t value) {
  GPBDescriptor *descriptor = [KinStorageKinTransaction descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:KinStorageKinTransaction_FieldNumber_Status];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - Enum KinStorageKinTransaction_Status

GPBEnumDescriptor *KinStorageKinTransaction_Status_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "Unknown\000Inflight\000Acknowledged\000Historical"
        "\000";
    static const int32_t values[] = {
        KinStorageKinTransaction_Status_Unknown,
        KinStorageKinTransaction_Status_Inflight,
        KinStorageKinTransaction_Status_Acknowledged,
        KinStorageKinTransaction_Status_Historical,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(KinStorageKinTransaction_Status)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:KinStorageKinTransaction_Status_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL KinStorageKinTransaction_Status_IsValidValue(int32_t value__) {
  switch (value__) {
    case KinStorageKinTransaction_Status_Unknown:
    case KinStorageKinTransaction_Status_Inflight:
    case KinStorageKinTransaction_Status_Acknowledged:
    case KinStorageKinTransaction_Status_Historical:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - KinStorageKinTransactions

@implementation KinStorageKinTransactions

@dynamic itemsArray, itemsArray_Count;
@dynamic headPagingToken;
@dynamic tailPagingToken;

typedef struct KinStorageKinTransactions__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *itemsArray;
  NSString *headPagingToken;
  NSString *tailPagingToken;
} KinStorageKinTransactions__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "itemsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(KinStorageKinTransaction),
        .number = KinStorageKinTransactions_FieldNumber_ItemsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(KinStorageKinTransactions__storage_, itemsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "headPagingToken",
        .dataTypeSpecific.className = NULL,
        .number = KinStorageKinTransactions_FieldNumber_HeadPagingToken,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(KinStorageKinTransactions__storage_, headPagingToken),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "tailPagingToken",
        .dataTypeSpecific.className = NULL,
        .number = KinStorageKinTransactions_FieldNumber_TailPagingToken,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(KinStorageKinTransactions__storage_, tailPagingToken),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[KinStorageKinTransactions class]
                                     rootClass:[KinStorageStorageRoot class]
                                          file:KinStorageStorageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(KinStorageKinTransactions__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - KinStorageInvoiceListBlob

@implementation KinStorageInvoiceListBlob

@dynamic networkInvoiceList;

typedef struct KinStorageInvoiceListBlob__storage_ {
  uint32_t _has_storage_[1];
  NSData *networkInvoiceList;
} KinStorageInvoiceListBlob__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "networkInvoiceList",
        .dataTypeSpecific.className = NULL,
        .number = KinStorageInvoiceListBlob_FieldNumber_NetworkInvoiceList,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(KinStorageInvoiceListBlob__storage_, networkInvoiceList),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[KinStorageInvoiceListBlob class]
                                     rootClass:[KinStorageStorageRoot class]
                                          file:KinStorageStorageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(KinStorageInvoiceListBlob__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\022\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - KinStorageInvoices

@implementation KinStorageInvoices

@dynamic invoiceLists, invoiceLists_Count;

typedef struct KinStorageInvoices__storage_ {
  uint32_t _has_storage_[1];
  NSMutableDictionary *invoiceLists;
} KinStorageInvoices__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "invoiceLists",
        .dataTypeSpecific.className = GPBStringifySymbol(KinStorageInvoiceListBlob),
        .number = KinStorageInvoices_FieldNumber_InvoiceLists,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(KinStorageInvoices__storage_, invoiceLists),
        .flags = (GPBFieldFlags)(GPBFieldMapKeyString | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[KinStorageInvoices class]
                                     rootClass:[KinStorageStorageRoot class]
                                          file:KinStorageStorageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(KinStorageInvoices__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\014\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - KinStorageKinConfig

@implementation KinStorageKinConfig

@dynamic minFee;
@dynamic cid;
@dynamic minApiVersion;

typedef struct KinStorageKinConfig__storage_ {
  uint32_t _has_storage_[1];
  NSString *cid;
  int64_t minFee;
  int64_t minApiVersion;
} KinStorageKinConfig__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "minFee",
        .dataTypeSpecific.className = NULL,
        .number = KinStorageKinConfig_FieldNumber_MinFee,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(KinStorageKinConfig__storage_, minFee),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "cid",
        .dataTypeSpecific.className = NULL,
        .number = KinStorageKinConfig_FieldNumber_Cid,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(KinStorageKinConfig__storage_, cid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "minApiVersion",
        .dataTypeSpecific.className = NULL,
        .number = KinStorageKinConfig_FieldNumber_MinApiVersion,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(KinStorageKinConfig__storage_, minApiVersion),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[KinStorageKinConfig class]
                                     rootClass:[KinStorageStorageRoot class]
                                          file:KinStorageStorageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(KinStorageKinConfig__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\003\r\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
